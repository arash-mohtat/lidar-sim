# lidar-sim

Python, C++ and MATLAB code for simple simulation of a multi-channel lidar.
The 3 libraries share some similarities but are independent (stand-alone) and feature different levels of functionalities.
The most notable similarities are:
(a) the use of an object-oriented architecture with body (target) and lidar classes as the main focus and some other auxiliary classes; 
(b) heavy use of vectorization for efficient casting of laser rays on geometric primitives.
As such they can be referenced as fun intermediate-level pedagogical projects for learning Python (numpy), C++ (Eigen/Dense) and MATLAB.

## The Python Implementation
Uses only Python 3.7, numpy and pandas for the computations, and PIL and Matplotlib for quick internal visualizations. Meshlab is highly recommended for better visualization of rendered pointclouds of complex objects or a complex scene. Only objects meshed with triangles are supported at the moment: two comma separated text files with three columns are needed (one with xyz cols and another with integer number defining the vertices connectivity) for each object to be scanned in the environment. The lidar class simulates an ideal multi-channel spherical lidar with a customizable uniform rectangular azimuth-elevation grid. A simple pinhole camera view of the field-of-view of the lidar with superposed scan lines is rendered using PIL. The scan lines are the hyperbolic curves resulting from azimuth-elevation changing rays intersecting the near clipping image plane of the camera a focal length away from the pinhole (lidar spherical center). The focal length is computed so as to be compatible with the desired horizontal and vertical field-of-view for the lidar with acceptable pixel resolution when rendering the 2d camera-like image. The pointcloud is computed independently from the 2d image using ray casting. If time permits, another scanning method might be added that uses 2d depth map image sampling for reconstructing the pointcloud while also using GPU acceleration. For now, everything has been implemented from scratch. Rendering a poitcloud resulting from a complex object with 200k vertices and 60k triangles takes only about 5 sec in Python thanks to vectorized numpy calculations and targeted casting of relevant rays on triangles.

## The C++ Implementation
The C++ implementation follows closely that of the Python implementation with the Eigen/Dense library replacing numpy. GCC 9.3 on Ubuntu 20.04 (C++17 features have been used), Eigen 3.3.9, CMake and Qt Creator were used. No visualization capability has yet been added and the implementation is not yet optimized or even finalized (as of early Jan 2021).

## The MATLAB Implementation
Uses MATLAB 2017 and no particular toolbox. The MATLAB implementation has the most extensive visualization capabilities and the highest fidelity lidar simulation. A Velodyne VLP16 lidar with full-fidelity rotation, pulse timing and channel intrinsics (such as vertical correction for individual channels) as well as measurement noises has been implemented. This is specially useful to study what happens when the channels are miscalibrated, e.g. if the laser beams are emitted at a slightly different angle than what is expected, and what type of artifacts are created in the perceived xyz pointcloud. The major drawback of the MATLAB implementation is that only simple geometric primitives (spheres and polygons) are implemented at the moment with no efficient automated mechanism for looping through thousands and thousands of polygons for scanning complex objects. The original purpose was studying and designing automated algorithms for intrinsic calibration of lidars where you mostly need simple geometries such as flat planes. For scanning complex scenes with hundreds of thousands of points and polygons, its likely that C++ MEX files will be needed!